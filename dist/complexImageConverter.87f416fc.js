!function(n){var I={};function e(t){if(I[t])return I[t].exports;var g=I[t]={i:t,l:!1,exports:{}};return n[t].call(g.exports,g,g.exports,e),g.l=!0,g.exports}e.m=n,e.c=I,e.d=function(n,I,t){e.o(n,I)||Object.defineProperty(n,I,{enumerable:!0,get:t})},e.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},e.t=function(n,I){if(1&I&&(n=e(n)),8&I)return n;if(4&I&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(e.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&I&&"string"!=typeof n)for(var g in n)e.d(t,g,function(I){return n[I]}.bind(null,g));return t},e.n=function(n){var I=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(I,"a",I),I},e.o=function(n,I){return Object.prototype.hasOwnProperty.call(n,I)},e.p="dist/",e(e.s=4)}([function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(2);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcz9hMzRhIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG4iXSwibWFwcGluZ3MiOiJBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n")},function(module,exports){eval('function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanM/Yzk3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXN5bmNUb0dlbmVyYXRvcjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n')},function(module,exports,__webpack_require__){eval('/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() {\n  return this || (typeof self === "object" && self);\n})() || Function("return this")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(3);\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzP2JiZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPSAoZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzIHx8ICh0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiAmJiBzZWxmKTtcbn0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n')},function(module,exports){eval('/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  "use strict";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === "function" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || "@@iterator";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";\n  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";\n\n  var inModule = typeof module === "object";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we\'re in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don\'t bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we\'re in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there\'s no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don\'t have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: "normal", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: "throw", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = "suspendedStart";\n  var GenStateSuspendedYield = "suspendedYield";\n  var GenStateExecuting = "executing";\n  var GenStateCompleted = "completed";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don\'t natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = "GeneratorFunction";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    ["next", "throw", "return"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === "function" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === "GeneratorFunction"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = "GeneratorFunction";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, "__await")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === "throw") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === "object" &&\n            hasOwn.call(value, "__await")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke("next", value, resolve, reject);\n          }, function(err) {\n            invoke("throw", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke("throw", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error("Generator is already running");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === "throw") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === "next") {\n          // Setting context._sent for legacy support of Babel\'s\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === "throw") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === "return") {\n          context.abrupt("return", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === "normal") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === "throw") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = "throw";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === "throw") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = "return";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === "throw") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // "return" to "throw", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = "throw";\n        context.arg = new TypeError(\n          "The iterator does not provide a \'throw\' method");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === "throw") {\n      context.method = "throw";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = "throw";\n      context.arg = new TypeError("iterator result is not an object");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was "throw" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was "next", forget context.arg since it has been\n      // "consumed" by the delegate iterator. If context.method was\n      // "return", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== "return") {\n        context.method = "next";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = "Generator";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers\' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn\'t happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return "[object Generator]";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = "normal";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: "root" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === "function") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel\'s\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = "next";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === "t" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === "throw") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = "throw";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = "next";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === "root") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle("end");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, "catchLoc");\n          var hasFinally = hasOwn.call(entry, "finallyLoc");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error("try statement without catch or finally");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, "finallyLoc") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === "break" ||\n           type === "continue") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = "next";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === "throw") {\n        throw record.arg;\n      }\n\n      if (record.type === "break" ||\n          record.type === "continue") {\n        this.next = record.arg;\n      } else if (record.type === "return") {\n        this.rval = this.arg = record.arg;\n        this.method = "return";\n        this.next = "end";\n      } else if (record.type === "normal" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    "catch": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === "throw") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error("illegal catch attempt");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === "next") {\n        // Deliberately forget the last sent value so that we don\'t\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we\'re in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() {\n    return this || (typeof self === "object" && self);\n  })() || Function("return this")()\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanM/OTZjZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBJbiBzbG9wcHkgbW9kZSwgdW5ib3VuZCBgdGhpc2AgcmVmZXJzIHRvIHRoZSBnbG9iYWwgb2JqZWN0LCBmYWxsYmFjayB0b1xuICAvLyBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpZiB3ZSdyZSBpbiBnbG9iYWwgc3RyaWN0IG1vZGUuIFRoYXQgaXMgc2FkbHkgYSBmb3JtXG4gIC8vIG9mIGluZGlyZWN0IGV2YWwgd2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXG4gIChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcyB8fCAodHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgJiYgc2VsZik7XG4gIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpXG4pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./app/lib/constants.js\nvar TEXT = 'text';\nvar MAPDATA = 'mapdata';\nvar MUSIC = 'music';\nvar MIDI = 'midi';\nvar MP3 = 'mp3';\nvar PNG = 'png';\nvar MUS = 'mus';\nvar GRAPHIC = 'graphic';\nvar FLAT = 'flat';\nvar MARKER = 'marker';\nvar ENDOOM = 'ENDOOM';\nvar TEXTUREx = ['TEXTURE1', 'TEXTURE2'];\nvar TEXTLUMPS = ['DEHACKED', 'MAPINFO', 'ZMAPINFO', 'EMAPINFO', 'DMXGUS', 'DMXGUSC', 'WADINFO', 'EMENUS', 'MUSINFO', 'SNDINFO', 'GLDEFS', 'KEYCONF', 'SCRIPTS', 'LANGUAGE', 'DECORATE', 'SBARINFO', 'MENUDEF'];\nvar DATA_LUMPS = ['PLAYPAL', 'COLORMAP', 'TEXTURE1', 'TEXTURE2', 'PNAMES', 'ENDOOM'];\nvar DEFAULT_EXTENSION = 'lmp';\nvar EXTENSIONS = {\n  text: 'txt',\n  mp3: 'mp3',\n  mus: 'mus',\n  midi: 'mid',\n  png: 'png'\n};\n/* Environment */\n\nvar NO_BRAND_ENV = 'development-no-brand';\n/* Workers */\n\nvar SERVICE_WORKER_CORE = 'service-worker-core.js';\n/* Web worker internal errors */\n\nvar INVALID_TEXT = 'INVALID_TEXT';\n/* Themes */\n\nvar DARK_THEME = 'dark';\nvar LIGHT_THEME = 'light';\n/* Input types */\n\nvar CHECKBOX = 'checkbox';\n/* File formats */\n\nvar SUPPORTED_FORMATS = ['.wad', '.zip', '.pk3', '.json'];\nvar VALID_FILE_FORMATS = ['', 'application/x-doom', 'application/zip', 'application/json'];\n/* WAD types */\n\nvar IWAD = 'IWAD';\nvar PWAD = 'PWAD';\nvar VALID_WAD_TYPES = [IWAD, PWAD];\n/* Lump types */\n\nvar MAP = 'maps';\nvar INTERMISSION = 'intermission';\nvar STATUS_BAR = 'status bar';\nvar MENU = 'menu';\nvar IMAGE_LUMPS = ['patches', 'flats', 'sprites', MENU, INTERMISSION, STATUS_BAR];\nvar UNCATEGORIZED = 'uncategorized';\n/* Lump names */\n\nvar THINGS = 'THINGS';\nvar TEXTMAP = 'TEXTMAP';\nvar ENDMAP = 'ENDMAP';\nvar MAP_LUMPS = [THINGS, 'LINEDEFS', 'SIDEDEFS', 'VERTEXES', 'SEGS', 'TEXTMAP', 'SSECTORS', 'NODES', 'SECTORS', 'REJECT', 'BLOCKMAP', // Hexen only\n'BEHAVIOR', // ZDoom only? (optional)\n'SCRIPTS', // Universal Doom Map Format only\n'ZNODES', 'DIALOGUE'];\nvar OPENGL_MAP_LUMPS = ['GL_VERT', 'GL_SEGS', 'GL_SSECT', 'GL_NODES', 'GL_PVS'];\nvar START_MARKERS = new RegExp(/^[0-9a-zA-Z]{0,2}_START$/);\nvar END_MARKERS = new RegExp(/^[0-9a-zA-Z]{0,2}_END$/);\nvar TEXTURE_LUMPS = new RegExp(/^TEXTURE[0-9a-zA-Z]$/);\nvar INTERMISSION_LUMPS = new RegExp(/^WI[0-9a-zA-Z_]{1,}$/); // Doom II\n\nvar INTERMISSION_MAP_NAME_LUMPS = new RegExp(/^CWILV[0-9a-zA-Z_]{1,}$/);\nvar STATUS_BAR_LUMPS = new RegExp(/^(ST|AMM|BRDR_)[0-9a-zA-Z_]{1,}$/);\n/* Unique lumps */\n\nvar ANSI_LUMPS = [// Doom or Chex Quest\n'ENDOOM', // Heretic\n'ENDTEXT', // Strife\n'ENDSTRF', // Boom\n'ENDBOOM'];\nvar MAPINFO = ['MAPINFO', 'ZMAPINFO'];\nvar PLAYPAL = 'PLAYPAL';\nvar COLORMAP = 'COLORMAP';\nvar PNAMES = 'PNAMES';\nvar SBARINFO = 'SBARINFO'; // Hexen only\n\nvar SNDINFO = 'SNDINFO';\nvar MENU_SCREENS = ['TITLEPIC', 'HELP', 'HELP1', 'HELP2', 'CREDIT'];\nvar INTER_SCREENS = ['INTERPIC', // Doom 1 registered\n'ENDPIC', 'VICTORY2', 'PFUB1', 'PFUB2', // Doom 2\n'BOSSBACK'];\nvar MUSIC_LUMPS = ['GENMIDI', 'DMXGUS', 'DMXGUSC'];\nvar DEMO_LUMPS = ['DEMO1', 'DEMO2', 'DEMO3', 'DEMO4'];\nvar END_LUMPS = new RegExp(/^END[0-9]{1,}$/);\n/* Lump original formats */\n\nvar ANSI = 'ANSI';\n/* Lump special values */\n\nvar LUMP_INDEX_ENTRY_SIZE = 16;\nvar LUMP_INDEX_ENTRY_OFFSET_TO_LUMP_SIZE = 4;\nvar LUMP_INDEX_ENTRY_OFFSET_TO_LUMP_NAME = 8;\nvar COLOR_COUNT_PER_PALETTE = 256;\nvar PALETTE_SIZE = 768;\nvar COLORMAP_SIZE = 256;\nvar BYTES_PER_COLOR = 3;\nvar GREEN_COLOR_OFFSET = 1;\nvar BLUE_COLOR_OFFSET = 2;\nvar FLAT_DIMENSIONS = 64;\nvar IMAGE_DATA_HEADER_SIZE = 8;\nvar IMAGE_DATA_BOUNDARY = 255;\nvar TRANSPARENT_PIXEL = -1;\nvar HEXEN_SOUND_ARCHIVE_PATH = '$ARCHIVEPATH';\nvar HEXEN_SOUND_REGISTERED = '$REGISTERED';\nvar HEXEN_MUSIC_KEYWORD = '$MAP';\n/* MUS -> MIDI conversion */\n\nvar MUS_HEADER = 'MUS';\nvar MUS_HEADER_SIGNATURE = ['M'.charCodeAt(0), 'U'.charCodeAt(0), 'S'.charCodeAt(0), 0x1A].join(' ');\nvar MIDI_HEADER = 'MThd';\nvar MIDI_HEADER_SIZE = 4;\nvar MIDI_HEADER_DATA = ['M'.charCodeAt(0), 'T'.charCodeAt(0), 'h'.charCodeAt(0), 'd'.charCodeAt(0), // Main header\n0x00, 0x00, 0x00, 0x06, // Header size\n0x00, 0x00, // MIDI type (0)\n0x00, 0x01, // Number of tracks\n0x00, 0x46, // Resolution\n'M'.charCodeAt(0), 'T'.charCodeAt(0), 'r'.charCodeAt(0), 'k'.charCodeAt(0), // Start of track\n0x00, 0x00, 0x00, 0x00];\nvar MUS_NUM_CHANNELS = 16;\nvar MUS_PERCUSSION_CHANNEL = 15;\nvar MIDI_PERCUSSION_CHANNEL = 9;\nvar MIDI_TRACKLENGTH_OFS = 18;\nvar MIDI_CONTROLLER_MAP = [0x00, 0x20, 0x01, 0x07, 0x0A, 0x0B, 0x5B, 0x5D, 0x40, 0x43, 0x78, 0x7B, 0x7E, 0x7F, 0x79]; // MUS event codes\n\nvar MUS_RELEASE_KEY = 0x00;\nvar MUS_PRESS_KEY = 0x10;\nvar MUS_PITCH_WHEEL = 0x20;\nvar MUS_SYSTEM_EVENT = 0x30;\nvar MUS_CHANGE_CONTROLLER = 0x40;\nvar MUS_SCORE_END = 0x60; // MIDI event codes\n\nvar MIDI_RELEASE_KEY = 0x80;\nvar MIDI_PRESS_KEY = 0x90;\nvar MIDI_CHANGE_CONTROLLER = 0xB0;\nvar MIDI_CHANGE_PATCH = 0xC0;\nvar MIDI_PITCH_WHEEL = 0xE0;\n/* MIDI player */\n\nvar MAX_I16 = Math.pow(2, 15);\nvar MIDI_AUDIO_BUFFER_SIZE = 8192; // signed 16-bit samples\n\nvar MIDI_AUDIO_S16LSB = 0x8010;\nvar MIDI_PATCH_URL = '/public/midi/pat/';\nvar MIDI_PLAYER_MESSAGE_PREFIX = 'Midi player:';\nvar MIDI_ERROR = 'MIDI_ERROR';\nvar MIDI_STATUS = 'MIDI_STATUS';\nvar MIDI_PRELOAD = 'MIDI_PRELOAD';\nvar MIDI_LOAD_FILE = 'MIDI_LOAD_FILE';\nvar MIDI_LOAD_PATCH = 'MIDI_LOAD_PATCH';\nvar MIDI_PLAY = 'MIDI_PLAY';\nvar MIDI_PAUSE = 'MIDI_PAUSE';\nvar MIDI_RESUME = 'MIDI_RESUME';\nvar MIDI_STOP = 'MIDI_STOP';\nvar MIDI_END = 'MIDI_END';\n/* DMX -> PCM conversion */\n\nvar DMX_HEADER_SIZE = 18;\nvar DMX_TAIL_PADDING = 2;\n/* PCM Player */\n\nvar DEFAULT_PCM_SAMPLE_RATE = 11025;\nvar DEFAULT_PCM_CONFIGURATION = {\n  encoding: '8bit',\n  channels: 1,\n  volume: 1,\n  logging: false\n};\nvar PCM_MAX_VALUES = {\n  '8bit': 255,\n  '16bit': 65535,\n  '32bit': 4294967295,\n  '32bitFloat': 1\n};\nvar PCM_TYPED_ARRAYS = {\n  '8bit': Uint8Array,\n  '16bit': Uint16Array,\n  '32bit': Uint32Array,\n  '32bitFloat': Float32Array\n};\nvar PCM_PLAYER_MESSAGE_PREFIX = 'PCM player:';\nvar PCM_STATUS = 'PCM_STATUS';\nvar PCM_ERROR = 'PCM_ERROR';\nvar PCM_PLAY = 'PCM_PLAY';\nvar PCM_PAUSE = 'PCM_PAUSE';\nvar PCM_STOP = 'PCM_STOP';\nvar PCM_END = 'PCM_END';\n/* ANSI conversion */\n\nvar ANSI_CODE_PAGE_437_TABLES = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ' ', '!', '\"', '#', '$', '%', '&', '\\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', '\\\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ' '];\nvar ANSI_BACKGROUND_COLOR_CODES = ['black', 'blue', 'green', 'cyan', 'red', 'magenta', 'brown', 'light-gray'];\nvar ANSI_FOREGROUND_COLOR_CODES = ['black', 'blue', 'green', 'cyan', 'red', 'magenta', 'brown', 'light-gray', 'dark-gray', 'light-blue', 'light-green', 'light-cyan', 'light-red', 'light-magenta', 'yellow', 'white'];\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js\nvar regenerator = __webpack_require__(0);\nvar regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js\nvar asyncToGenerator = __webpack_require__(1);\nvar asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator);\n\n// CONCATENATED MODULE: ./app/lib/convertColorIndexesReferencesToBlob.js\n\n\n\nfunction convertColorIndexesReferencesToBlob(_x, _x2, _x3, _x4) {\n  return _convertColorIndexesReferencesToBlob.apply(this, arguments);\n}\n\nfunction _convertColorIndexesReferencesToBlob() {\n  _convertColorIndexesReferencesToBlob = asyncToGenerator_default()(\n  /*#__PURE__*/\n  regenerator_default.a.mark(function _callee(colorIndexReferences, width, height, palette) {\n    var canvas, context, imageData, i, _palette$colorIndexRe, red, green, blue, newCanvas, blob;\n\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!(!palette || palette.length !== COLOR_COUNT_PER_PALETTE)) {\n              _context.next = 3;\n              break;\n            }\n\n            console.error('The palette does not have enough colors to draw images.', palette);\n            return _context.abrupt(\"return\", null);\n\n          case 3:\n            _context.prev = 3;\n            canvas = new OffscreenCanvas(height, width);\n            canvas.height = height;\n            canvas.width = width;\n            context = canvas.getContext('2d');\n            imageData = context.createImageData(canvas.width, canvas.height);\n\n            for (i = 0; i < colorIndexReferences.length; i++) {\n              if (colorIndexReferences[i] === TRANSPARENT_PIXEL) {\n                imageData.data[i * 4 + 3] = 0;\n              } else {\n                _palette$colorIndexRe = palette[colorIndexReferences[i]], red = _palette$colorIndexRe.red, green = _palette$colorIndexRe.green, blue = _palette$colorIndexRe.blue;\n                imageData.data[i * 4 + 0] = red;\n                imageData.data[i * 4 + 1] = green;\n                imageData.data[i * 4 + 2] = blue;\n                imageData.data[i * 4 + 3] = 255;\n              }\n            }\n\n            newCanvas = new OffscreenCanvas(height, width);\n            newCanvas.height = imageData.height;\n            newCanvas.width = imageData.width;\n            newCanvas.getContext('2d').putImageData(imageData, 0, 0);\n            context.imageSmoothingEnabled = false;\n            context.drawImage(newCanvas, 0, 0);\n            _context.next = 18;\n            return canvas.convertToBlob();\n\n          case 18:\n            blob = _context.sent;\n            return _context.abrupt(\"return\", blob);\n\n          case 22:\n            _context.prev = 22;\n            _context.t0 = _context[\"catch\"](3);\n            console.error('An error occurred while converting color index references to a blob', {\n              error: _context.t0\n            });\n            return _context.abrupt(\"return\", '');\n\n          case 26:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[3, 22]]);\n  }));\n  return _convertColorIndexesReferencesToBlob.apply(this, arguments);\n}\n// CONCATENATED MODULE: ./app/lib/cacheManager.js\n\n\nvar setCacheItemAsBlob = function setCacheItemAsBlob(_ref) {\n  var cacheId = _ref.cacheId,\n      requestURL = _ref.requestURL,\n      responseData = _ref.responseData;\n  var response = new Response(responseData);\n  caches.open(cacheId).then(function (cache) {\n    return cache.put(requestURL, response);\n  });\n};\nvar getCacheItemAsArrayBuffer =\n/*#__PURE__*/\nfunction () {\n  var _ref3 = asyncToGenerator_default()(\n  /*#__PURE__*/\n  regenerator_default.a.mark(function _callee(_ref2) {\n    var cacheId, requestURL, cache, response;\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            cacheId = _ref2.cacheId, requestURL = _ref2.requestURL;\n            _context.prev = 1;\n            _context.next = 4;\n            return caches.open(cacheId);\n\n          case 4:\n            cache = _context.sent;\n            _context.next = 7;\n            return cache.match(requestURL);\n\n          case 7:\n            response = _context.sent;\n\n            if (response) {\n              _context.next = 10;\n              break;\n            }\n\n            return _context.abrupt(\"return\", null);\n\n          case 10:\n            _context.next = 12;\n            return response.arrayBuffer();\n\n          case 12:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 15:\n            _context.prev = 15;\n            _context.t0 = _context[\"catch\"](1);\n            console.error(\"An error occurred while retrieving cache of '\".concat(requestURL, \"'.\"), {\n              error: _context.t0\n            });\n            return _context.abrupt(\"return\", null);\n\n          case 19:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[1, 15]]);\n  }));\n\n  return function getCacheItemAsArrayBuffer(_x) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nvar getCacheItemAsBlob =\n/*#__PURE__*/\nfunction () {\n  var _ref5 = asyncToGenerator_default()(\n  /*#__PURE__*/\n  regenerator_default.a.mark(function _callee2(_ref4) {\n    var cacheId, requestURL, cache, response;\n    return regenerator_default.a.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            cacheId = _ref4.cacheId, requestURL = _ref4.requestURL;\n            _context2.prev = 1;\n            _context2.next = 4;\n            return caches.open(cacheId);\n\n          case 4:\n            cache = _context2.sent;\n            _context2.next = 7;\n            return cache.match(requestURL);\n\n          case 7:\n            response = _context2.sent;\n\n            if (response) {\n              _context2.next = 10;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", null);\n\n          case 10:\n            _context2.next = 12;\n            return response.blob();\n\n          case 12:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 15:\n            _context2.prev = 15;\n            _context2.t0 = _context2[\"catch\"](1);\n            console.error(\"An error occurred while retrieving cache of '\".concat(requestURL, \"'.\"), {\n              error: _context2.t0\n            });\n            return _context2.abrupt(\"return\", null);\n\n          case 19:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[1, 15]]);\n  }));\n\n  return function getCacheItemAsBlob(_x2) {\n    return _ref5.apply(this, arguments);\n  };\n}();\nvar getCacheItemAsJson =\n/*#__PURE__*/\nfunction () {\n  var _ref7 = asyncToGenerator_default()(\n  /*#__PURE__*/\n  regenerator_default.a.mark(function _callee3(_ref6) {\n    var cacheId, requestURL, cache, response;\n    return regenerator_default.a.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            cacheId = _ref6.cacheId, requestURL = _ref6.requestURL;\n            _context3.prev = 1;\n            _context3.next = 4;\n            return caches.open(cacheId);\n\n          case 4:\n            cache = _context3.sent;\n            _context3.next = 7;\n            return cache.match(requestURL);\n\n          case 7:\n            response = _context3.sent;\n\n            if (response) {\n              _context3.next = 10;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", null);\n\n          case 10:\n            _context3.next = 12;\n            return response.json();\n\n          case 12:\n            return _context3.abrupt(\"return\", _context3.sent);\n\n          case 15:\n            _context3.prev = 15;\n            _context3.t0 = _context3[\"catch\"](1);\n            console.error(\"An error occurred while retrieving cache of '\".concat(requestURL, \"'.\"), {\n              error: _context3.t0\n            });\n            return _context3.abrupt(\"return\", null);\n\n          case 19:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[1, 15]]);\n  }));\n\n  return function getCacheItemAsJson(_x3) {\n    return _ref7.apply(this, arguments);\n  };\n}();\nvar getCacheItemAsText =\n/*#__PURE__*/\nfunction () {\n  var _ref9 = asyncToGenerator_default()(\n  /*#__PURE__*/\n  regenerator_default.a.mark(function _callee4(_ref8) {\n    var cacheId, requestURL, cache, response;\n    return regenerator_default.a.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            cacheId = _ref8.cacheId, requestURL = _ref8.requestURL;\n            _context4.prev = 1;\n            _context4.next = 4;\n            return caches.open(cacheId);\n\n          case 4:\n            cache = _context4.sent;\n            _context4.next = 7;\n            return cache.match(requestURL);\n\n          case 7:\n            response = _context4.sent;\n\n            if (response) {\n              _context4.next = 10;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", null);\n\n          case 10:\n            _context4.next = 12;\n            return response.text();\n\n          case 12:\n            return _context4.abrupt(\"return\", _context4.sent);\n\n          case 15:\n            _context4.prev = 15;\n            _context4.t0 = _context4[\"catch\"](1);\n            console.error(\"An error occurred while retrieving cache of '\".concat(requestURL, \"'.\"), {\n              error: _context4.t0\n            });\n            return _context4.abrupt(\"return\", null);\n\n          case 19:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, null, [[1, 15]]);\n  }));\n\n  return function getCacheItemAsText(_x4) {\n    return _ref9.apply(this, arguments);\n  };\n}();\nvar deleteCache =\n/*#__PURE__*/\nfunction () {\n  var _ref11 = asyncToGenerator_default()(\n  /*#__PURE__*/\n  regenerator_default.a.mark(function _callee5(_ref10) {\n    var cacheId;\n    return regenerator_default.a.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            cacheId = _ref10.cacheId;\n            _context5.prev = 1;\n            _context5.next = 4;\n            return caches.delete(cacheId);\n\n          case 4:\n            return _context5.abrupt(\"return\", true);\n\n          case 7:\n            _context5.prev = 7;\n            _context5.t0 = _context5[\"catch\"](1);\n            console.error(\"An error occurred while deleting cache of '\".concat(cacheId, \"'.\"), {\n              error: _context5.t0\n            });\n            return _context5.abrupt(\"return\", false);\n\n          case 11:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5, null, [[1, 7]]);\n  }));\n\n  return function deleteCache(_x5) {\n    return _ref11.apply(this, arguments);\n  };\n}();\nvar deleteAllCache =\n/*#__PURE__*/\nfunction () {\n  var _ref12 = asyncToGenerator_default()(\n  /*#__PURE__*/\n  regenerator_default.a.mark(function _callee7() {\n    var cacheKeys;\n    return regenerator_default.a.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            _context7.prev = 0;\n            _context7.next = 3;\n            return caches.keys();\n\n          case 3:\n            cacheKeys = _context7.sent;\n            _context7.next = 6;\n            return cacheKeys.map(\n            /*#__PURE__*/\n            function () {\n              var _ref13 = asyncToGenerator_default()(\n              /*#__PURE__*/\n              regenerator_default.a.mark(function _callee6(key) {\n                return regenerator_default.a.wrap(function _callee6$(_context6) {\n                  while (1) {\n                    switch (_context6.prev = _context6.next) {\n                      case 0:\n                        _context6.next = 2;\n                        return caches.delete(key);\n\n                      case 2:\n                      case \"end\":\n                        return _context6.stop();\n                    }\n                  }\n                }, _callee6);\n              }));\n\n              return function (_x6) {\n                return _ref13.apply(this, arguments);\n              };\n            }());\n\n          case 6:\n            return _context7.abrupt(\"return\", true);\n\n          case 9:\n            _context7.prev = 9;\n            _context7.t0 = _context7[\"catch\"](0);\n            console.error('An error occurred while deleting the cache.', {\n              error: _context7.t0\n            });\n            return _context7.abrupt(\"return\", false);\n\n          case 13:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7, null, [[0, 9]]);\n  }));\n\n  return function deleteAllCache() {\n    return _ref12.apply(this, arguments);\n  };\n}();\n// CONCATENATED MODULE: ./app/webWorkers/complexImageConverter.js\n\n\n\n\n\n\nfunction buildColorIndexReferences(data, width, height) {\n    try {\n        const colorIndexes = [];\n\n        // assume that the whole image is transparent\n        for (let i = 0; i < width; i++) {\n            for (let j = 0; j < height; j++) {\n                colorIndexes.push(TRANSPARENT_PIXEL);\n            }\n        }\n\n        const columnAddresses = [];\n        for (let i = 0; i < width; i++) {\n            columnAddresses[i] = data.getUint32(8 + (i * 4), true);\n        }\n\n        let position = 0;\n        let pixelCount = 0;\n\n        for (let i = 0; i < width; i++) {\n            position = columnAddresses[i];\n            let rowStart = 0;\n\n            while (rowStart !== IMAGE_DATA_BOUNDARY) {\n                rowStart = data.getUint8(position);\n                position += 1;\n\n                if (rowStart === IMAGE_DATA_BOUNDARY) break;\n\n                pixelCount = data.getUint8(position);\n                position += 2;\n\n                for (let j = 0; j < pixelCount; j++) {\n                    colorIndexes[((rowStart + j) * width) + i] = data.getUint8(position);\n                    position += 1;\n                }\n                position += 1;\n            }\n        }\n        return colorIndexes;\n    } catch (error) {\n        console.error('An error occurred while building color index references', { error });\n        return { error };\n    }\n}\n\nonmessage = async (message) => {\n    const {\n        wadId,\n        lump,\n        palette,\n    } = message.data;\n\n    const {\n        name,\n        type,\n        data,\n        width,\n        height,\n    } = lump;\n\n    // console.log(`Converting '${type}/${name}' from complex image to PNG data URL (WAD: '${wadId}') ...`);\n\n    const requestURL = `/complexImages/${wadId}/${name}`;\n    const cachedItem = await getCacheItemAsBlob({ cacheId: wadId, requestURL });\n\n    if (cachedItem) {\n        postMessage({\n            wadId,\n            lumpId: name,\n            lumpType: type,\n            output: cachedItem,\n        });\n\n        return;\n    }\n\n    const colorIndexReferences = buildColorIndexReferences(data, width, height);\n\n    const image = await convertColorIndexesReferencesToBlob(\n        colorIndexReferences,\n        width,\n        height,\n        palette,\n    );\n\n    if (image && !image.error) {\n        // console.log(`Converted '${type}/${name}' from complex image to blob (WAD: '${wadId}').`);\n        setCacheItemAsBlob({ cacheId: wadId, requestURL, responseData: image });\n        postMessage({\n            wadId,\n            lumpId: name,\n            lumpType: type,\n            output: image,\n        });\n    } else {\n        console.error(`Could not convert '${name}' from complex image to blob (WAD: '${wadId}').`);\n        postMessage({\n            wadId,\n            lumpId: name,\n            lumpType: type,\n            error: image.error,\n        });\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2FwcC9saWIvY29uc3RhbnRzLmpzP2I2NGQiLCJ3ZWJwYWNrOi8vLy4vYXBwL2xpYi9jb252ZXJ0Q29sb3JJbmRleGVzUmVmZXJlbmNlc1RvQmxvYi5qcz9kZDBiIiwid2VicGFjazovLy8uL2FwcC9saWIvY2FjaGVNYW5hZ2VyLmpzP2EzOTIiLCJ3ZWJwYWNrOi8vLy4vYXBwL3dlYldvcmtlcnMvY29tcGxleEltYWdlQ29udmVydGVyLmpzP2I5OTgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IFRFWFQgPSAndGV4dCc7XG5leHBvcnQgY29uc3QgTUFQREFUQSA9ICdtYXBkYXRhJztcbmV4cG9ydCBjb25zdCBNVVNJQyA9ICdtdXNpYyc7XG5leHBvcnQgY29uc3QgTUlESSA9ICdtaWRpJztcbmV4cG9ydCBjb25zdCBNUDMgPSAnbXAzJztcbmV4cG9ydCBjb25zdCBQTkcgPSAncG5nJztcbmV4cG9ydCBjb25zdCBNVVMgPSAnbXVzJztcbmV4cG9ydCBjb25zdCBHUkFQSElDID0gJ2dyYXBoaWMnO1xuZXhwb3J0IGNvbnN0IEZMQVQgPSAnZmxhdCc7XG5leHBvcnQgY29uc3QgTUFSS0VSID0gJ21hcmtlcic7XG5leHBvcnQgY29uc3QgRU5ET09NID0gJ0VORE9PTSc7XG5leHBvcnQgY29uc3QgVEVYVFVSRXggPSBbJ1RFWFRVUkUxJywgJ1RFWFRVUkUyJ107XG5cbmV4cG9ydCBjb25zdCBURVhUTFVNUFMgPSBbJ0RFSEFDS0VEJywgJ01BUElORk8nLCAnWk1BUElORk8nLCAnRU1BUElORk8nLFxuICAgICdETVhHVVMnLCAnRE1YR1VTQycsICdXQURJTkZPJywgJ0VNRU5VUycsICdNVVNJTkZPJyxcbiAgICAnU05ESU5GTycsICdHTERFRlMnLCAnS0VZQ09ORicsICdTQ1JJUFRTJywgJ0xBTkdVQUdFJyxcbiAgICAnREVDT1JBVEUnLCAnU0JBUklORk8nLCAnTUVOVURFRiddO1xuZXhwb3J0IGNvbnN0IERBVEFfTFVNUFMgPSBbJ1BMQVlQQUwnLCAnQ09MT1JNQVAnLCAnVEVYVFVSRTEnLCAnVEVYVFVSRTInLCAnUE5BTUVTJyxcbiAgICAnRU5ET09NJ107XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0VYVEVOU0lPTiA9ICdsbXAnO1xuZXhwb3J0IGNvbnN0IEVYVEVOU0lPTlMgPSB7XG4gICAgdGV4dDogJ3R4dCcsXG4gICAgbXAzOiAnbXAzJyxcbiAgICBtdXM6ICdtdXMnLFxuICAgIG1pZGk6ICdtaWQnLFxuICAgIHBuZzogJ3BuZycsXG59O1xuXG4vKiBFbnZpcm9ubWVudCAqL1xuXG5leHBvcnQgY29uc3QgTk9fQlJBTkRfRU5WID0gJ2RldmVsb3BtZW50LW5vLWJyYW5kJztcblxuLyogV29ya2VycyAqL1xuXG5leHBvcnQgY29uc3QgU0VSVklDRV9XT1JLRVJfQ09SRSA9ICdzZXJ2aWNlLXdvcmtlci1jb3JlLmpzJztcblxuLyogV2ViIHdvcmtlciBpbnRlcm5hbCBlcnJvcnMgKi9cblxuZXhwb3J0IGNvbnN0IElOVkFMSURfVEVYVCA9ICdJTlZBTElEX1RFWFQnO1xuXG4vKiBUaGVtZXMgKi9cblxuZXhwb3J0IGNvbnN0IERBUktfVEhFTUUgPSAnZGFyayc7XG5cbmV4cG9ydCBjb25zdCBMSUdIVF9USEVNRSA9ICdsaWdodCc7XG5cbi8qIElucHV0IHR5cGVzICovXG5cbmV4cG9ydCBjb25zdCBDSEVDS0JPWCA9ICdjaGVja2JveCc7XG5cbi8qIEZpbGUgZm9ybWF0cyAqL1xuXG5leHBvcnQgY29uc3QgU1VQUE9SVEVEX0ZPUk1BVFMgPSBbXG4gICAgJy53YWQnLFxuICAgICcuemlwJyxcbiAgICAnLnBrMycsXG4gICAgJy5qc29uJyxcbl07XG5cbmV4cG9ydCBjb25zdCBWQUxJRF9GSUxFX0ZPUk1BVFMgPSBbXG4gICAgJycsXG4gICAgJ2FwcGxpY2F0aW9uL3gtZG9vbScsXG4gICAgJ2FwcGxpY2F0aW9uL3ppcCcsXG4gICAgJ2FwcGxpY2F0aW9uL2pzb24nLFxuXTtcblxuLyogV0FEIHR5cGVzICovXG5cbmV4cG9ydCBjb25zdCBJV0FEID0gJ0lXQUQnO1xuZXhwb3J0IGNvbnN0IFBXQUQgPSAnUFdBRCc7XG5leHBvcnQgY29uc3QgVkFMSURfV0FEX1RZUEVTID0gW0lXQUQsIFBXQURdO1xuXG4vKiBMdW1wIHR5cGVzICovXG5cbmV4cG9ydCBjb25zdCBNQVAgPSAnbWFwcyc7XG5cbmV4cG9ydCBjb25zdCBJTlRFUk1JU1NJT04gPSAnaW50ZXJtaXNzaW9uJztcblxuZXhwb3J0IGNvbnN0IFNUQVRVU19CQVIgPSAnc3RhdHVzIGJhcic7XG5cbmV4cG9ydCBjb25zdCBNRU5VID0gJ21lbnUnO1xuXG5leHBvcnQgY29uc3QgSU1BR0VfTFVNUFMgPSBbXG4gICAgJ3BhdGNoZXMnLFxuICAgICdmbGF0cycsXG4gICAgJ3Nwcml0ZXMnLFxuICAgIE1FTlUsXG4gICAgSU5URVJNSVNTSU9OLFxuICAgIFNUQVRVU19CQVIsXG5dO1xuXG5leHBvcnQgY29uc3QgVU5DQVRFR09SSVpFRCA9ICd1bmNhdGVnb3JpemVkJztcblxuLyogTHVtcCBuYW1lcyAqL1xuXG5leHBvcnQgY29uc3QgVEhJTkdTID0gJ1RISU5HUyc7XG5cbmV4cG9ydCBjb25zdCBURVhUTUFQID0gJ1RFWFRNQVAnO1xuXG5leHBvcnQgY29uc3QgRU5ETUFQID0gJ0VORE1BUCc7XG5cbmV4cG9ydCBjb25zdCBNQVBfTFVNUFMgPSBbXG4gICAgVEhJTkdTLFxuICAgICdMSU5FREVGUycsXG4gICAgJ1NJREVERUZTJyxcbiAgICAnVkVSVEVYRVMnLFxuICAgICdTRUdTJyxcbiAgICAnVEVYVE1BUCcsXG4gICAgJ1NTRUNUT1JTJyxcbiAgICAnTk9ERVMnLFxuICAgICdTRUNUT1JTJyxcbiAgICAnUkVKRUNUJyxcbiAgICAnQkxPQ0tNQVAnLFxuICAgIC8vIEhleGVuIG9ubHlcbiAgICAnQkVIQVZJT1InLFxuICAgIC8vIFpEb29tIG9ubHk/IChvcHRpb25hbClcbiAgICAnU0NSSVBUUycsXG4gICAgLy8gVW5pdmVyc2FsIERvb20gTWFwIEZvcm1hdCBvbmx5XG4gICAgJ1pOT0RFUycsXG4gICAgJ0RJQUxPR1VFJyxcbl07XG5cbmV4cG9ydCBjb25zdCBPUEVOR0xfTUFQX0xVTVBTID0gW1xuICAgICdHTF9WRVJUJyxcbiAgICAnR0xfU0VHUycsXG4gICAgJ0dMX1NTRUNUJyxcbiAgICAnR0xfTk9ERVMnLFxuICAgICdHTF9QVlMnLFxuXTtcblxuZXhwb3J0IGNvbnN0IFNUQVJUX01BUktFUlMgPSBuZXcgUmVnRXhwKC9eWzAtOWEtekEtWl17MCwyfV9TVEFSVCQvKTtcblxuZXhwb3J0IGNvbnN0IEVORF9NQVJLRVJTID0gbmV3IFJlZ0V4cCgvXlswLTlhLXpBLVpdezAsMn1fRU5EJC8pO1xuXG5leHBvcnQgY29uc3QgVEVYVFVSRV9MVU1QUyA9IG5ldyBSZWdFeHAoL15URVhUVVJFWzAtOWEtekEtWl0kLyk7XG5cbmV4cG9ydCBjb25zdCBJTlRFUk1JU1NJT05fTFVNUFMgPSBuZXcgUmVnRXhwKC9eV0lbMC05YS16QS1aX117MSx9JC8pO1xuXG4vLyBEb29tIElJXG5leHBvcnQgY29uc3QgSU5URVJNSVNTSU9OX01BUF9OQU1FX0xVTVBTID0gbmV3IFJlZ0V4cCgvXkNXSUxWWzAtOWEtekEtWl9dezEsfSQvKTtcblxuZXhwb3J0IGNvbnN0IFNUQVRVU19CQVJfTFVNUFMgPSBuZXcgUmVnRXhwKC9eKFNUfEFNTXxCUkRSXylbMC05YS16QS1aX117MSx9JC8pO1xuXG4vKiBVbmlxdWUgbHVtcHMgKi9cblxuZXhwb3J0IGNvbnN0IEFOU0lfTFVNUFMgPSBbXG4gICAgLy8gRG9vbSBvciBDaGV4IFF1ZXN0XG4gICAgJ0VORE9PTScsXG4gICAgLy8gSGVyZXRpY1xuICAgICdFTkRURVhUJyxcbiAgICAvLyBTdHJpZmVcbiAgICAnRU5EU1RSRicsXG4gICAgLy8gQm9vbVxuICAgICdFTkRCT09NJyxcbiAgICAvLyBsYWNrIG9mIEFOU0kgbHVtcCBpbiBJV0FEID0gSGV4ZW5cbl07XG5cbmV4cG9ydCBjb25zdCBNQVBJTkZPID0gWydNQVBJTkZPJywgJ1pNQVBJTkZPJ107XG5cbmV4cG9ydCBjb25zdCBQTEFZUEFMID0gJ1BMQVlQQUwnO1xuZXhwb3J0IGNvbnN0IENPTE9STUFQID0gJ0NPTE9STUFQJztcblxuZXhwb3J0IGNvbnN0IFBOQU1FUyA9ICdQTkFNRVMnO1xuXG5leHBvcnQgY29uc3QgU0JBUklORk8gPSAnU0JBUklORk8nO1xuXG4vLyBIZXhlbiBvbmx5XG5leHBvcnQgY29uc3QgU05ESU5GTyA9ICdTTkRJTkZPJztcblxuZXhwb3J0IGNvbnN0IE1FTlVfU0NSRUVOUyA9IFtcbiAgICAnVElUTEVQSUMnLFxuICAgICdIRUxQJyxcbiAgICAnSEVMUDEnLFxuICAgICdIRUxQMicsXG4gICAgJ0NSRURJVCcsXG5dO1xuXG5leHBvcnQgY29uc3QgSU5URVJfU0NSRUVOUyA9IFtcbiAgICAnSU5URVJQSUMnLFxuICAgIC8vIERvb20gMSByZWdpc3RlcmVkXG4gICAgJ0VORFBJQycsXG4gICAgJ1ZJQ1RPUlkyJyxcbiAgICAnUEZVQjEnLFxuICAgICdQRlVCMicsXG4gICAgLy8gRG9vbSAyXG4gICAgJ0JPU1NCQUNLJyxcbl07XG5cbmV4cG9ydCBjb25zdCBNVVNJQ19MVU1QUyA9IFtcbiAgICAnR0VOTUlESScsXG4gICAgJ0RNWEdVUycsXG4gICAgJ0RNWEdVU0MnLFxuXTtcblxuZXhwb3J0IGNvbnN0IERFTU9fTFVNUFMgPSBbXG4gICAgJ0RFTU8xJyxcbiAgICAnREVNTzInLFxuICAgICdERU1PMycsXG4gICAgJ0RFTU80Jyxcbl07XG5cbmV4cG9ydCBjb25zdCBFTkRfTFVNUFMgPSBuZXcgUmVnRXhwKC9eRU5EWzAtOV17MSx9JC8pO1xuXG4vKiBMdW1wIG9yaWdpbmFsIGZvcm1hdHMgKi9cblxuZXhwb3J0IGNvbnN0IEFOU0kgPSAnQU5TSSc7XG5cbi8qIEx1bXAgc3BlY2lhbCB2YWx1ZXMgKi9cblxuZXhwb3J0IGNvbnN0IExVTVBfSU5ERVhfRU5UUllfU0laRSA9IDE2O1xuZXhwb3J0IGNvbnN0IExVTVBfSU5ERVhfRU5UUllfT0ZGU0VUX1RPX0xVTVBfU0laRSA9IDQ7XG5leHBvcnQgY29uc3QgTFVNUF9JTkRFWF9FTlRSWV9PRkZTRVRfVE9fTFVNUF9OQU1FID0gODtcblxuZXhwb3J0IGNvbnN0IENPTE9SX0NPVU5UX1BFUl9QQUxFVFRFID0gMjU2O1xuZXhwb3J0IGNvbnN0IFBBTEVUVEVfU0laRSA9IDc2ODtcbmV4cG9ydCBjb25zdCBDT0xPUk1BUF9TSVpFID0gMjU2O1xuXG5leHBvcnQgY29uc3QgQllURVNfUEVSX0NPTE9SID0gMztcbmV4cG9ydCBjb25zdCBHUkVFTl9DT0xPUl9PRkZTRVQgPSAxO1xuZXhwb3J0IGNvbnN0IEJMVUVfQ09MT1JfT0ZGU0VUID0gMjtcblxuZXhwb3J0IGNvbnN0IEZMQVRfRElNRU5TSU9OUyA9IDY0O1xuXG5leHBvcnQgY29uc3QgSU1BR0VfREFUQV9IRUFERVJfU0laRSA9IDg7XG5leHBvcnQgY29uc3QgSU1BR0VfREFUQV9CT1VOREFSWSA9IDI1NTtcblxuZXhwb3J0IGNvbnN0IFRSQU5TUEFSRU5UX1BJWEVMID0gLTE7XG5cbmV4cG9ydCBjb25zdCBIRVhFTl9TT1VORF9BUkNISVZFX1BBVEggPSAnJEFSQ0hJVkVQQVRIJztcblxuZXhwb3J0IGNvbnN0IEhFWEVOX1NPVU5EX1JFR0lTVEVSRUQgPSAnJFJFR0lTVEVSRUQnO1xuXG5leHBvcnQgY29uc3QgSEVYRU5fTVVTSUNfS0VZV09SRCA9ICckTUFQJztcblxuLyogTVVTIC0+IE1JREkgY29udmVyc2lvbiAqL1xuXG5leHBvcnQgY29uc3QgTVVTX0hFQURFUiA9ICdNVVMnO1xuZXhwb3J0IGNvbnN0IE1VU19IRUFERVJfU0lHTkFUVVJFID0gWydNJy5jaGFyQ29kZUF0KDApLCAnVScuY2hhckNvZGVBdCgwKSwgJ1MnLmNoYXJDb2RlQXQoMCksIDB4MUFdLmpvaW4oJyAnKTtcbmV4cG9ydCBjb25zdCBNSURJX0hFQURFUiA9ICdNVGhkJztcbmV4cG9ydCBjb25zdCBNSURJX0hFQURFUl9TSVpFID0gNDtcbmV4cG9ydCBjb25zdCBNSURJX0hFQURFUl9EQVRBID0gW1xuICAgICdNJy5jaGFyQ29kZUF0KDApLCAnVCcuY2hhckNvZGVBdCgwKSwgJ2gnLmNoYXJDb2RlQXQoMCksICdkJy5jaGFyQ29kZUF0KDApLCAvLyBNYWluIGhlYWRlclxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDYsIC8vIEhlYWRlciBzaXplXG4gICAgMHgwMCwgMHgwMCwgLy8gTUlESSB0eXBlICgwKVxuICAgIDB4MDAsIDB4MDEsIC8vIE51bWJlciBvZiB0cmFja3NcbiAgICAweDAwLCAweDQ2LCAvLyBSZXNvbHV0aW9uXG4gICAgJ00nLmNoYXJDb2RlQXQoMCksICdUJy5jaGFyQ29kZUF0KDApLCAncicuY2hhckNvZGVBdCgwKSwgJ2snLmNoYXJDb2RlQXQoMCksIC8vIFN0YXJ0IG9mIHRyYWNrXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gUGxhY2Vob2xkZXIgZm9yIHRyYWNrIGxlbmd0aFxuXTtcblxuZXhwb3J0IGNvbnN0IE1VU19OVU1fQ0hBTk5FTFMgPSAxNjtcbmV4cG9ydCBjb25zdCBNVVNfUEVSQ1VTU0lPTl9DSEFOTkVMID0gMTU7XG5leHBvcnQgY29uc3QgTUlESV9QRVJDVVNTSU9OX0NIQU5ORUwgPSA5O1xuZXhwb3J0IGNvbnN0IE1JRElfVFJBQ0tMRU5HVEhfT0ZTID0gMTg7XG5cbmV4cG9ydCBjb25zdCBNSURJX0NPTlRST0xMRVJfTUFQID0gW1xuICAgIDB4MDAsIDB4MjAsIDB4MDEsIDB4MDcsIDB4MEEsIDB4MEIsIDB4NUIsIDB4NUQsIDB4NDAsIDB4NDMsIDB4NzgsIDB4N0IsIDB4N0UsIDB4N0YsIDB4NzksXG5dO1xuXG4vLyBNVVMgZXZlbnQgY29kZXNcbmV4cG9ydCBjb25zdCBNVVNfUkVMRUFTRV9LRVkgPSAweDAwO1xuZXhwb3J0IGNvbnN0IE1VU19QUkVTU19LRVkgPSAweDEwO1xuZXhwb3J0IGNvbnN0IE1VU19QSVRDSF9XSEVFTCA9IDB4MjA7XG5leHBvcnQgY29uc3QgTVVTX1NZU1RFTV9FVkVOVCA9IDB4MzA7XG5leHBvcnQgY29uc3QgTVVTX0NIQU5HRV9DT05UUk9MTEVSID0gMHg0MDtcbmV4cG9ydCBjb25zdCBNVVNfU0NPUkVfRU5EID0gMHg2MDtcblxuLy8gTUlESSBldmVudCBjb2Rlc1xuZXhwb3J0IGNvbnN0IE1JRElfUkVMRUFTRV9LRVkgPSAweDgwO1xuZXhwb3J0IGNvbnN0IE1JRElfUFJFU1NfS0VZID0gMHg5MDtcbmV4cG9ydCBjb25zdCBNSURJX0NIQU5HRV9DT05UUk9MTEVSID0gMHhCMDtcbmV4cG9ydCBjb25zdCBNSURJX0NIQU5HRV9QQVRDSCA9IDB4QzA7XG5leHBvcnQgY29uc3QgTUlESV9QSVRDSF9XSEVFTCA9IDB4RTA7XG5cbi8qIE1JREkgcGxheWVyICovXG5cbmV4cG9ydCBjb25zdCBNQVhfSTE2ID0gMiAqKiAxNTtcblxuZXhwb3J0IGNvbnN0IE1JRElfQVVESU9fQlVGRkVSX1NJWkUgPSA4MTkyO1xuXG4vLyBzaWduZWQgMTYtYml0IHNhbXBsZXNcbmV4cG9ydCBjb25zdCBNSURJX0FVRElPX1MxNkxTQiA9IDB4ODAxMDtcblxuZXhwb3J0IGNvbnN0IE1JRElfUEFUQ0hfVVJMID0gJy9wdWJsaWMvbWlkaS9wYXQvJztcblxuZXhwb3J0IGNvbnN0IE1JRElfUExBWUVSX01FU1NBR0VfUFJFRklYID0gJ01pZGkgcGxheWVyOic7XG5cbmV4cG9ydCBjb25zdCBNSURJX0VSUk9SID0gJ01JRElfRVJST1InO1xuXG5leHBvcnQgY29uc3QgTUlESV9TVEFUVVMgPSAnTUlESV9TVEFUVVMnO1xuXG5leHBvcnQgY29uc3QgTUlESV9QUkVMT0FEID0gJ01JRElfUFJFTE9BRCc7XG5cbmV4cG9ydCBjb25zdCBNSURJX0xPQURfRklMRSA9ICdNSURJX0xPQURfRklMRSc7XG5cbmV4cG9ydCBjb25zdCBNSURJX0xPQURfUEFUQ0ggPSAnTUlESV9MT0FEX1BBVENIJztcblxuZXhwb3J0IGNvbnN0IE1JRElfUExBWSA9ICdNSURJX1BMQVknO1xuXG5leHBvcnQgY29uc3QgTUlESV9QQVVTRSA9ICdNSURJX1BBVVNFJztcblxuZXhwb3J0IGNvbnN0IE1JRElfUkVTVU1FID0gJ01JRElfUkVTVU1FJztcblxuZXhwb3J0IGNvbnN0IE1JRElfU1RPUCA9ICdNSURJX1NUT1AnO1xuXG5leHBvcnQgY29uc3QgTUlESV9FTkQgPSAnTUlESV9FTkQnO1xuXG4vKiBETVggLT4gUENNIGNvbnZlcnNpb24gKi9cblxuZXhwb3J0IGNvbnN0IERNWF9IRUFERVJfU0laRSA9IDE4O1xuXG5leHBvcnQgY29uc3QgRE1YX1RBSUxfUEFERElORyA9IDI7XG5cbi8qIFBDTSBQbGF5ZXIgKi9cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfUENNX1NBTVBMRV9SQVRFID0gMTEwMjU7XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1BDTV9DT05GSUdVUkFUSU9OID0ge1xuICAgIGVuY29kaW5nOiAnOGJpdCcsXG4gICAgY2hhbm5lbHM6IDEsXG4gICAgdm9sdW1lOiAxLFxuICAgIGxvZ2dpbmc6IGZhbHNlLFxufTtcblxuZXhwb3J0IGNvbnN0IFBDTV9NQVhfVkFMVUVTID0ge1xuICAgICc4Yml0JzogMjU1LFxuICAgICcxNmJpdCc6IDY1NTM1LFxuICAgICczMmJpdCc6IDQyOTQ5NjcyOTUsXG4gICAgJzMyYml0RmxvYXQnOiAxLFxufTtcblxuZXhwb3J0IGNvbnN0IFBDTV9UWVBFRF9BUlJBWVMgPSB7XG4gICAgJzhiaXQnOiBVaW50OEFycmF5LFxuICAgICcxNmJpdCc6IFVpbnQxNkFycmF5LFxuICAgICczMmJpdCc6IFVpbnQzMkFycmF5LFxuICAgICczMmJpdEZsb2F0JzogRmxvYXQzMkFycmF5LFxufTtcblxuZXhwb3J0IGNvbnN0IFBDTV9QTEFZRVJfTUVTU0FHRV9QUkVGSVggPSAnUENNIHBsYXllcjonO1xuXG5leHBvcnQgY29uc3QgUENNX1NUQVRVUyA9ICdQQ01fU1RBVFVTJztcblxuZXhwb3J0IGNvbnN0IFBDTV9FUlJPUiA9ICdQQ01fRVJST1InO1xuXG5leHBvcnQgY29uc3QgUENNX1BMQVkgPSAnUENNX1BMQVknO1xuXG5leHBvcnQgY29uc3QgUENNX1BBVVNFID0gJ1BDTV9QQVVTRSc7XG5cbmV4cG9ydCBjb25zdCBQQ01fU1RPUCA9ICdQQ01fU1RPUCc7XG5cbmV4cG9ydCBjb25zdCBQQ01fRU5EID0gJ1BDTV9FTkQnO1xuXG4vKiBBTlNJIGNvbnZlcnNpb24gKi9cblxuZXhwb3J0IGNvbnN0IEFOU0lfQ09ERV9QQUdFXzQzN19UQUJMRVMgPSBbXG4gICAgJycsICfimLonLCAn4pi7JywgJ+KZpScsICfimaYnLCAn4pmjJywgJ+KZoCcsICfigKInLCAn4peYJywgJ+KXiycsICfil5knLCAn4pmCJywgJ+KZgCcsICfimaonLCAn4pmrJywgJ+KYvCcsXG4gICAgJ+KWuicsICfil4QnLCAn4oaVJywgJ+KAvCcsICfCticsICfCpycsICfilqwnLCAn4oaoJywgJ+KGkScsICfihpMnLCAn4oaSJywgJ+KGkCcsICfiiJ8nLCAn4oaUJywgJ+KWsicsICfilrwnLFxuICAgICcgJywgJyEnLCAnXCInLCAnIycsICckJywgJyUnLCAnJicsICdcXCcnLCAnKCcsICcpJywgJyonLCAnKycsICcsJywgJy0nLCAnLicsICcvJyxcbiAgICAnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsICc6JywgJzsnLCAnPCcsICc9JywgJz4nLCAnPycsXG4gICAgJ0AnLCAnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnLCAnRycsICdIJywgJ0knLCAnSicsICdLJywgJ0wnLCAnTScsICdOJywgJ08nLFxuICAgICdQJywgJ1EnLCAnUicsICdTJywgJ1QnLCAnVScsICdWJywgJ1cnLCAnWCcsICdZJywgJ1onLCAnWycsICdcXFxcJywgJ10nLCAnXicsICdfJyxcbiAgICAnYCcsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsXG4gICAgJ3AnLCAncScsICdyJywgJ3MnLCAndCcsICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneicsICd7JywgJ3wnLCAnfScsICd+JywgJ+KMgicsXG4gICAgJ8OHJywgJ8O8JywgJ8OpJywgJ8OiJywgJ8OkJywgJ8OgJywgJ8OlJywgJ8OnJywgJ8OqJywgJ8OrJywgJ8OoJywgJ8OvJywgJ8OuJywgJ8OsJywgJ8OEJywgJ8OFJyxcbiAgICAnw4knLCAnw6YnLCAnw4YnLCAnw7QnLCAnw7YnLCAnw7InLCAnw7snLCAnw7knLCAnw78nLCAnw5YnLCAnw5wnLCAnwqInLCAnwqMnLCAnwqUnLCAn4oKnJywgJ8aSJyxcbiAgICAnw6EnLCAnw60nLCAnw7MnLCAnw7onLCAnw7EnLCAnw5EnLCAnwqonLCAnwronLCAnwr8nLCAn4oyQJywgJ8KsJywgJ8K9JywgJ8K8JywgJ8KhJywgJ8KrJywgJ8K7JyxcbiAgICAn4paRJywgJ+KWkicsICfilpMnLCAn4pSCJywgJ+KUpCcsICfilaEnLCAn4pWiJywgJ+KVlicsICfilZUnLCAn4pWjJywgJ+KVkScsICfilZcnLCAn4pWdJywgJ+KVnCcsICfilZsnLCAn4pSQJyxcbiAgICAn4pSUJywgJ+KUtCcsICfilKwnLCAn4pScJywgJ+KUgCcsICfilLwnLCAn4pWeJywgJ+KVnycsICfilZonLCAn4pWUJywgJ+KVqScsICfilaYnLCAn4pWgJywgJ+KVkCcsICfilawnLCAn4pWnJyxcbiAgICAn4pWoJywgJ+KVpCcsICfilaUnLCAn4pWZJywgJ+KVmCcsICfilZInLCAn4pWTJywgJ+KVqycsICfilaonLCAn4pSYJywgJ+KUjCcsICfilognLCAn4paEJywgJ+KWjCcsICfilpAnLCAn4paAJyxcbiAgICAnzrEnLCAnw58nLCAnzpMnLCAnz4AnLCAnzqMnLCAnz4MnLCAnwrUnLCAnz4QnLCAnzqYnLCAnzpgnLCAnzqknLCAnzrQnLCAn4oieJywgJ8+GJywgJ861JywgJ+KIqScsXG4gICAgJ+KJoScsICfCsScsICfiiaUnLCAn4omkJywgJ+KMoCcsICfijKEnLCAnw7cnLCAn4omIJywgJ8KwJywgJ+KImScsICfCtycsICfiiJonLCAn4oG/JywgJ8KyJywgJ+KWoCcsICcgJyxcbl07XG5cbmV4cG9ydCBjb25zdCBBTlNJX0JBQ0tHUk9VTkRfQ09MT1JfQ09ERVMgPSBbXG4gICAgJ2JsYWNrJyxcbiAgICAnYmx1ZScsXG4gICAgJ2dyZWVuJyxcbiAgICAnY3lhbicsXG4gICAgJ3JlZCcsXG4gICAgJ21hZ2VudGEnLFxuICAgICdicm93bicsXG4gICAgJ2xpZ2h0LWdyYXknLFxuXTtcblxuZXhwb3J0IGNvbnN0IEFOU0lfRk9SRUdST1VORF9DT0xPUl9DT0RFUyA9IFtcbiAgICAnYmxhY2snLFxuICAgICdibHVlJyxcbiAgICAnZ3JlZW4nLFxuICAgICdjeWFuJyxcbiAgICAncmVkJyxcbiAgICAnbWFnZW50YScsXG4gICAgJ2Jyb3duJyxcbiAgICAnbGlnaHQtZ3JheScsXG4gICAgJ2RhcmstZ3JheScsXG4gICAgJ2xpZ2h0LWJsdWUnLFxuICAgICdsaWdodC1ncmVlbicsXG4gICAgJ2xpZ2h0LWN5YW4nLFxuICAgICdsaWdodC1yZWQnLFxuICAgICdsaWdodC1tYWdlbnRhJyxcbiAgICAneWVsbG93JyxcbiAgICAnd2hpdGUnLFxuXTtcbiIsImltcG9ydCB7XG4gICAgVFJBTlNQQVJFTlRfUElYRUwsXG4gICAgQ09MT1JfQ09VTlRfUEVSX1BBTEVUVEUsXG59IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gY29udmVydENvbG9ySW5kZXhlc1JlZmVyZW5jZXNUb0Jsb2IoXG4gICAgY29sb3JJbmRleFJlZmVyZW5jZXMsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHBhbGV0dGUsXG4pIHtcbiAgICBpZiAoIXBhbGV0dGUgfHwgcGFsZXR0ZS5sZW5ndGggIT09IENPTE9SX0NPVU5UX1BFUl9QQUxFVFRFKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZSBwYWxldHRlIGRvZXMgbm90IGhhdmUgZW5vdWdoIGNvbG9ycyB0byBkcmF3IGltYWdlcy4nLCBwYWxldHRlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhoZWlnaHQsIHdpZHRoKTtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBjb250ZXh0LmNyZWF0ZUltYWdlRGF0YShcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQsXG4gICAgICAgICk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xvckluZGV4UmVmZXJlbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvbG9ySW5kZXhSZWZlcmVuY2VzW2ldID09PSBUUkFOU1BBUkVOVF9QSVhFTCkge1xuICAgICAgICAgICAgICAgIGltYWdlRGF0YS5kYXRhWyhpICogNCkgKyAzXSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVkLCBncmVlbiwgYmx1ZSB9ID0gcGFsZXR0ZVtjb2xvckluZGV4UmVmZXJlbmNlc1tpXV07XG4gICAgICAgICAgICAgICAgaW1hZ2VEYXRhLmRhdGFbKGkgKiA0KSArIDBdID0gcmVkO1xuICAgICAgICAgICAgICAgIGltYWdlRGF0YS5kYXRhWyhpICogNCkgKyAxXSA9IGdyZWVuO1xuICAgICAgICAgICAgICAgIGltYWdlRGF0YS5kYXRhWyhpICogNCkgKyAyXSA9IGJsdWU7XG4gICAgICAgICAgICAgICAgaW1hZ2VEYXRhLmRhdGFbKGkgKiA0KSArIDNdID0gMjU1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0NhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoaGVpZ2h0LCB3aWR0aCk7XG4gICAgICAgIG5ld0NhbnZhcy5oZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0O1xuICAgICAgICBuZXdDYW52YXMud2lkdGggPSBpbWFnZURhdGEud2lkdGg7XG4gICAgICAgIG5ld0NhbnZhcy5nZXRDb250ZXh0KCcyZCcpLnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgICAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShuZXdDYW52YXMsIDAsIDApO1xuXG4gICAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBjYW52YXMuY29udmVydFRvQmxvYigpO1xuXG4gICAgICAgIHJldHVybiBibG9iO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FuIGVycm9yIG9jY3VycmVkIHdoaWxlIGNvbnZlcnRpbmcgY29sb3IgaW5kZXggcmVmZXJlbmNlcyB0byBhIGJsb2InLCB7IGVycm9yIH0pO1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufVxuIiwiZXhwb3J0IGNvbnN0IHNldENhY2hlSXRlbUFzQmxvYiA9ICh7IGNhY2hlSWQsIHJlcXVlc3RVUkwsIHJlc3BvbnNlRGF0YSB9KSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UocmVzcG9uc2VEYXRhKTtcbiAgICBjYWNoZXMub3BlbihjYWNoZUlkKS50aGVuKGNhY2hlID0+IGNhY2hlLnB1dChyZXF1ZXN0VVJMLCByZXNwb25zZSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldENhY2hlSXRlbUFzQXJyYXlCdWZmZXIgPSBhc3luYyAoeyBjYWNoZUlkLCByZXF1ZXN0VVJMIH0pID0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjYWNoZSA9IGF3YWl0IGNhY2hlcy5vcGVuKGNhY2hlSWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNhY2hlLm1hdGNoKHJlcXVlc3RVUkwpO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgcmV0cmlldmluZyBjYWNoZSBvZiAnJHtyZXF1ZXN0VVJMfScuYCwgeyBlcnJvciB9KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldENhY2hlSXRlbUFzQmxvYiA9IGFzeW5jICh7IGNhY2hlSWQsIHJlcXVlc3RVUkwgfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gYXdhaXQgY2FjaGVzLm9wZW4oY2FjaGVJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2FjaGUubWF0Y2gocmVxdWVzdFVSTCk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEFuIGVycm9yIG9jY3VycmVkIHdoaWxlIHJldHJpZXZpbmcgY2FjaGUgb2YgJyR7cmVxdWVzdFVSTH0nLmAsIHsgZXJyb3IgfSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRDYWNoZUl0ZW1Bc0pzb24gPSBhc3luYyAoeyBjYWNoZUlkLCByZXF1ZXN0VVJMIH0pID0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjYWNoZSA9IGF3YWl0IGNhY2hlcy5vcGVuKGNhY2hlSWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNhY2hlLm1hdGNoKHJlcXVlc3RVUkwpO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSByZXRyaWV2aW5nIGNhY2hlIG9mICcke3JlcXVlc3RVUkx9Jy5gLCB7IGVycm9yIH0pO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0Q2FjaGVJdGVtQXNUZXh0ID0gYXN5bmMgKHsgY2FjaGVJZCwgcmVxdWVzdFVSTCB9KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBhd2FpdCBjYWNoZXMub3BlbihjYWNoZUlkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjYWNoZS5tYXRjaChyZXF1ZXN0VVJMKTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgcmV0cmlldmluZyBjYWNoZSBvZiAnJHtyZXF1ZXN0VVJMfScuYCwgeyBlcnJvciB9KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGRlbGV0ZUNhY2hlID0gYXN5bmMgKHsgY2FjaGVJZCB9KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgY2FjaGVzLmRlbGV0ZShjYWNoZUlkKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgZGVsZXRpbmcgY2FjaGUgb2YgJyR7Y2FjaGVJZH0nLmAsIHsgZXJyb3IgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5leHBvcnQgY29uc3QgZGVsZXRlQWxsQ2FjaGUgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2FjaGVLZXlzID0gYXdhaXQgY2FjaGVzLmtleXMoKTtcbiAgICAgICAgYXdhaXQgY2FjaGVLZXlzLm1hcChhc3luYyAoa2V5KSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBjYWNoZXMuZGVsZXRlKGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBkZWxldGluZyB0aGUgY2FjaGUuJywgeyBlcnJvciB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG4iLCJpbXBvcnQge1xuICAgIFRSQU5TUEFSRU5UX1BJWEVMLFxuICAgIElNQUdFX0RBVEFfQk9VTkRBUlksXG59IGZyb20gJy4uL2xpYi9jb25zdGFudHMnO1xuXG5pbXBvcnQgY29udmVydENvbG9ySW5kZXhlc1JlZmVyZW5jZXNUb0Jsb2IgZnJvbSAnLi4vbGliL2NvbnZlcnRDb2xvckluZGV4ZXNSZWZlcmVuY2VzVG9CbG9iJztcblxuaW1wb3J0IHtcbiAgICBnZXRDYWNoZUl0ZW1Bc0Jsb2IsXG4gICAgc2V0Q2FjaGVJdGVtQXNCbG9iLFxufSBmcm9tICcuLi9saWIvY2FjaGVNYW5hZ2VyJztcblxuZnVuY3Rpb24gYnVpbGRDb2xvckluZGV4UmVmZXJlbmNlcyhkYXRhLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY29sb3JJbmRleGVzID0gW107XG5cbiAgICAgICAgLy8gYXNzdW1lIHRoYXQgdGhlIHdob2xlIGltYWdlIGlzIHRyYW5zcGFyZW50XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBoZWlnaHQ7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbG9ySW5kZXhlcy5wdXNoKFRSQU5TUEFSRU5UX1BJWEVMKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbHVtbkFkZHJlc3NlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbHVtbkFkZHJlc3Nlc1tpXSA9IGRhdGEuZ2V0VWludDMyKDggKyAoaSAqIDQpLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwb3NpdGlvbiA9IDA7XG4gICAgICAgIGxldCBwaXhlbENvdW50ID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gY29sdW1uQWRkcmVzc2VzW2ldO1xuICAgICAgICAgICAgbGV0IHJvd1N0YXJ0ID0gMDtcblxuICAgICAgICAgICAgd2hpbGUgKHJvd1N0YXJ0ICE9PSBJTUFHRV9EQVRBX0JPVU5EQVJZKSB7XG4gICAgICAgICAgICAgICAgcm93U3RhcnQgPSBkYXRhLmdldFVpbnQ4KHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJvd1N0YXJ0ID09PSBJTUFHRV9EQVRBX0JPVU5EQVJZKSBicmVhaztcblxuICAgICAgICAgICAgICAgIHBpeGVsQ291bnQgPSBkYXRhLmdldFVpbnQ4KHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAyO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwaXhlbENvdW50OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JJbmRleGVzWygocm93U3RhcnQgKyBqKSAqIHdpZHRoKSArIGldID0gZGF0YS5nZXRVaW50OChwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbG9ySW5kZXhlcztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBidWlsZGluZyBjb2xvciBpbmRleCByZWZlcmVuY2VzJywgeyBlcnJvciB9KTtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgICB9XG59XG5cbm9ubWVzc2FnZSA9IGFzeW5jIChtZXNzYWdlKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgICB3YWRJZCxcbiAgICAgICAgbHVtcCxcbiAgICAgICAgcGFsZXR0ZSxcbiAgICB9ID0gbWVzc2FnZS5kYXRhO1xuXG4gICAgY29uc3Qge1xuICAgICAgICBuYW1lLFxuICAgICAgICB0eXBlLFxuICAgICAgICBkYXRhLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgIH0gPSBsdW1wO1xuXG4gICAgLy8gY29uc29sZS5sb2coYENvbnZlcnRpbmcgJyR7dHlwZX0vJHtuYW1lfScgZnJvbSBjb21wbGV4IGltYWdlIHRvIFBORyBkYXRhIFVSTCAoV0FEOiAnJHt3YWRJZH0nKSAuLi5gKTtcblxuICAgIGNvbnN0IHJlcXVlc3RVUkwgPSBgL2NvbXBsZXhJbWFnZXMvJHt3YWRJZH0vJHtuYW1lfWA7XG4gICAgY29uc3QgY2FjaGVkSXRlbSA9IGF3YWl0IGdldENhY2hlSXRlbUFzQmxvYih7IGNhY2hlSWQ6IHdhZElkLCByZXF1ZXN0VVJMIH0pO1xuXG4gICAgaWYgKGNhY2hlZEl0ZW0pIHtcbiAgICAgICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgd2FkSWQsXG4gICAgICAgICAgICBsdW1wSWQ6IG5hbWUsXG4gICAgICAgICAgICBsdW1wVHlwZTogdHlwZSxcbiAgICAgICAgICAgIG91dHB1dDogY2FjaGVkSXRlbSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbG9ySW5kZXhSZWZlcmVuY2VzID0gYnVpbGRDb2xvckluZGV4UmVmZXJlbmNlcyhkYXRhLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGNvbnN0IGltYWdlID0gYXdhaXQgY29udmVydENvbG9ySW5kZXhlc1JlZmVyZW5jZXNUb0Jsb2IoXG4gICAgICAgIGNvbG9ySW5kZXhSZWZlcmVuY2VzLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBwYWxldHRlLFxuICAgICk7XG5cbiAgICBpZiAoaW1hZ2UgJiYgIWltYWdlLmVycm9yKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGBDb252ZXJ0ZWQgJyR7dHlwZX0vJHtuYW1lfScgZnJvbSBjb21wbGV4IGltYWdlIHRvIGJsb2IgKFdBRDogJyR7d2FkSWR9JykuYCk7XG4gICAgICAgIHNldENhY2hlSXRlbUFzQmxvYih7IGNhY2hlSWQ6IHdhZElkLCByZXF1ZXN0VVJMLCByZXNwb25zZURhdGE6IGltYWdlIH0pO1xuICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB3YWRJZCxcbiAgICAgICAgICAgIGx1bXBJZDogbmFtZSxcbiAgICAgICAgICAgIGx1bXBUeXBlOiB0eXBlLFxuICAgICAgICAgICAgb3V0cHV0OiBpbWFnZSxcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgQ291bGQgbm90IGNvbnZlcnQgJyR7bmFtZX0nIGZyb20gY29tcGxleCBpbWFnZSB0byBibG9iIChXQUQ6ICcke3dhZElkfScpLmApO1xuICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB3YWRJZCxcbiAgICAgICAgICAgIGx1bXBJZDogbmFtZSxcbiAgICAgICAgICAgIGx1bXBUeXBlOiB0eXBlLFxuICAgICAgICAgICAgZXJyb3I6IGltYWdlLmVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG59O1xuIl0sIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBT0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFTQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQWFBO0FBRUE7QUFFQTtBQUlBO0FBUUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUlBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFRQTtBQUdBO0FBS0E7QUFHQTtBQU1BO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFtQkE7QUFXQTs7Ozs7Ozs7Ozs7O0FDallBO0FBS0E7QUFBQTtBQUFBO0FBQ0E7Ozs7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQVBBO0FBQ0E7QUFEQTtBQUFBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdENBO0FBQUE7QUFDQTtBQURBO0FBd0NBO0FBeENBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUE0Q0E7QUFBQTtBQUFBO0FBNUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7O0FDTEE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBRkE7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBSkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQVdBO0FBQUE7QUFBQTtBQVhBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFnQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBRkE7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBSkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQVdBO0FBQUE7QUFBQTtBQVhBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFnQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBRkE7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBSkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQVdBO0FBQUE7QUFBQTtBQVhBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFnQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBRkE7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBSkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQVdBO0FBQUE7QUFBQTtBQVhBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFnQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFLQTtBQUFBO0FBQUE7QUFMQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBVUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUZBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUpBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQVFBO0FBQUE7QUFBQTtBQVJBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n")}]);